#!/bin/sh
#
### [20140211][simonhuang] This file was copied and modified from linux/scripts/setlocalversion.
### It will generate two files, .scmurl and .scmversion
# This scripts adds local version information from the version
# control systems git, mercurial (hg) and subversion (svn).
#
# If something goes wrong, send a mail the kernel build mailinglist
# (see MAINTAINERS) and CC Nico Schottelius
# <nico-linuxsetlocalversion -at- schottelius.org>.
#
#

usage() {
	echo "Usage: $0 [--save-scmversion] [srctree]" >&2
	exit 1
}

scm_only=false
srctree=.
if test "$1" = "--save-scmversion"; then
	scm_only=true
	shift
fi
if test $# -gt 0; then
	srctree=$1
	shift
fi
if test $# -gt 0 -o ! -d "$srctree"; then
	usage
fi

scm_version()
{
	local short
	short=false

	cd "$srctree"
### [20140211][simonhuang] update .scmversion anyway
#	if test -e .scmversion; then
#		cat .scmversion
#		return
#	fi
	if test "$1" = "--short"; then
		short=true
	fi

	# Check for git and a git repo.
	if test -d .git && head=`git rev-parse --verify --short HEAD 2>/dev/null`; then

		# If we are at a tagged commit (like "v2.6.30-rc6"), we ignore
		# it, because this version is defined in the top level Makefile.
		if [ -z "`git describe --exact-match 2>/dev/null`" ]; then

			# If only the short version is requested, don't bother
			# running further git commands
			if $short; then
				echo "+"
				return
			fi
			# If we are past a tagged commit (like
			# "v2.6.30-rc5-302-g72357d5"), we pretty print it.
			if atag="`git describe 2>/dev/null`"; then
				echo "$atag" | awk -F- '{printf("-%05d-%s", $(NF-1),$(NF))}'

			# If we don't have a tag at all we print -g{commitish}.
			else
				printf '%s%s' -g $head
			fi
		fi

		# Is this git on svn?
		if git config --get svn-remote.svn.url >/dev/null; then
			printf -- '-svn%s' "`git svn find-rev $head`"
		fi

		# Update index only on r/w media
		[ -w . ] && git update-index --refresh --unmerged > /dev/null

		# Check for uncommitted changes
		if git diff-index --name-only HEAD | grep -v "^scripts/package" \
		    | read dummy; then
			printf '%s' -dirty
		fi

		# All done with git
		return
	fi

	# Check for mercurial and a mercurial repo.
	if test -d .hg && hgid=`hg id 2>/dev/null`; then
		# Do we have an tagged version?  If so, latesttagdistance == 1
		if [ "`hg log -r . --template '{latesttagdistance}'`" == "1" ]; then
			id=`hg log -r . --template '{latesttag}'`
			printf '%s%s' -hg "$id"
		else
			tag=`printf '%s' "$hgid" | cut -d' ' -f2`
			if [ -z "$tag" -o "$tag" = tip ]; then
				id=`printf '%s' "$hgid" | sed 's/[+ ].*//'`
				printf '%s%s' -hg "$id"
			fi
		fi

		# Are there uncommitted changes?
		# These are represented by + after the changeset id.
		case "$hgid" in
			*+|*+\ *) printf '%s' -dirty ;;
		esac

		# All done with mercurial
		return
	fi

	# Check for svn and a svn repo.
#	if rev=`svn info 2>/dev/null | grep '^Last Changed Rev'`; then
#		rev=`echo $rev`
#		rev=`echo $rev | awk '{print $NF}'`
#		printf -- '-svn%s' "$rev"
#
#		# All done with svn
#		return
#	fi

	if rev=`svn info 2>/dev/null | grep '^Revision'`; then
		rev=`echo $rev | awk '{print $NF}'`
        changes=`svn status 2>/dev/null | grep '^[AMD]' | wc -l`

        # Are there uncommitted changes?
        if [ $changes != 0 ]; then
                printf -- '-svn%s%s%s' "$rev" -dirty "$changes"
        else
		printf -- '-svn%s' "$rev"
        fi

		# All done with svn
		return
	fi
}

scm_url()
{
        cd "$srctree"

	if url=`svn info 2>/dev/null | grep '^URL'`; then
                url=`echo $url | awk '{print $NF}'`

        # Are there uncommitted changes?
                printf -- '%s' "$url"

                # All done with svn
                return
        fi
}

if $scm_only; then
#	if test ! -e .scmversion; then
		res=$(scm_version)
		echo "$res" >.scmversion
#	fi
		repos_url=$(scm_url)
		echo "$repos_url" > .scmurl
	exit
fi
